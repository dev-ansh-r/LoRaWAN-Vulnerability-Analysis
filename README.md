---
jupyter:
  colab:
  kernelspec:
    display_name: Python 3
    name: python3
  language_info:
    name: python
  nbformat: 4
  nbformat_minor: 0
---

::: {.cell .markdown id="iY5_7NB_JYbx"}
# LoRaWAN Vulnerabilities and Security Breaches Identification and Solution
:::

::: {.cell .markdown id="qUWcLELediIa"}
## Introduction
:::

::: {.cell .markdown id="p4IUhq8hLTl5"}
LoRaWAN is one of the most used LPWAN Protocol with atmost security as
it uses CSS ( Chirp Spread Spectrum Modulation). The Lorawan
Architecture is built around CSS and hence having security issues is
hard but still contains few.

## The LoRaWAN stack:

![The LoRaWAN
Stack](https://i.ibb.co/TbzYkC1/Screenshot-2024-01-18-144922.png) The
Architecture of the Lorawan consists of many security Keys using which
the existing security Methodology is built.

![Security keys in
LoraWAN](https://i.ibb.co/Fxp8Fdy/Screenshot-2024-01-18-120453.png)

The end devices sends the data to the Gateway which is sent to Network
Server followed by Application Server. For Each layer of transmission
one encryption Key is used.

![OTAA version
1.1](https://i.ibb.co/KrdGc67/Screenshot-2024-01-18-114409.png)
:::

::: {.cell .markdown id="SHMrEVYdeAgq"}
## Example Message Formats
:::

::: {.cell .markdown id="jCHEltBKeKD0"}
### Join-accept Message Sample
:::

::: {.cell .code id="WNaxK0rweFhh"}
``` python
{
  "end_device_ids" : {
    "device_id" : "dev1",
    "application_ids" : {
      "application_id" : "app1"
    },
    "dev_eui" : "0004A30B001C0530",
    "join_eui" : "800000000000000C",
    "dev_addr" : "01497ECC"
  },
  "correlation_ids" : [
    "as:up:01E191YN5F2HMBQCBCVRF731VY",
    "gs:conn:01E191S6ZEWB630NTR45K5QN4Q",
    "gs:uplink:01E191YMZ2S7ZRTEGATVE2S3HH",
    "ns:uplink:01E191YMZ2J64K6FEW5F0WE7TQ",
    "rpc:/ttn.lorawan.v3.GsNs/HandleUplink:01E191YMZ2KK3TJYG5C4XZP8JK"
  ],
  "received_at" : "2020-02-17T07:49:09.935284891Z",
  "join_accept" : {
    "session_key_id" : "AXBSH1Pk6Z0G166RlH16CQ==",
    "received_at" : "2020-02-17T07:49:09.736532315Z"
  }
}
```
:::

::: {.cell .markdown id="w0i_gRL_eNvH"}
### Uplink message Sample
:::

::: {.cell .code execution_count="1" id="PJxEfytkeUeD"}
``` python
{
  "end_device_ids" : {
    "device_id" : "dev1",
    "application_ids" : {
      "application_id" : "app1"
    },
    "dev_eui" : "0004A30B001C0530",
    "join_eui" : "800000000000000C",
    "dev_addr" : "00BCB929"
  },
  "correlation_ids" : [
    "as:up:01E0WZGT6Y7657CPFPE5WEYDSQ",
    "gs:conn:01E0WDEC6T5T4XXBAX7S1VMFKE",
    "gs:uplink:01E0WZGSZWT07NE5TS2APTV1Z9",
    "ns:uplink:01E0WZGSZXZXZS8RFAWZX0F2FY",
    "rpc:/ttn.lorawan.v3.GsNs/HandleUplink:01E0WZGSZXGE1KS577PFBWRJEE"
  ],
  "received_at" : "2020-02-12T15:15:46.014773143Z",
  "uplink_message" : {
    "session_key_id" : "AXA50tHUGUucuzS/bCGMNw==",
    "f_cnt" : 1,
    "frm_payload" : "gkHe",
    "decoded_payload" : {
      "temperature": 1.0,
      "luminosity": 0.64
    },
    "rx_metadata" : [ {
      "gateway_ids" : {
        "gateway_id" : "gtw1",
        "eui" : "9C5C8E00001A05C4"
      },
      "time" : "2020-02-12T15:15:45.787Z",
      "timestamp" : 2463457000,
      "rssi" : -35,
      "channel_rssi" : -35,
      "snr" : 5,
      "uplink_token" : "ChIKEAoEZ3R3MRIInFyOAAAaBcQQ6L3Vlgk=",
      "channel_index" : 2
    } ],
    "settings" : {
      "data_rate" : {
        "lora" : {
          "bandwidth" : 125000,
          "spreading_factor" : 7
        }
      },
      "coding_rate" : "4/6",
      "frequency" : "868300000",
      "timestamp" : 2463457000,
      "time" : "2020-02-12T15:15:45.787Z"
    },
    "consumed_airtime": "0.056576s",
    "locations": {
      "user": {
        "latitude": 37.97155556731436,
        "longitude": 23.72678801175413,
        "altitude": 10,
        "source": "SOURCE_REGISTRY"
      }
    },
    "version_ids": {
        "brand_id": "the-things-products",
        "model_id": "the-things-uno",
        "hardware_version": "1.0",
        "firmware_version": "quickstart",
        "band_id": "US_902_928"
    },
    "network_ids": {
      "net_id": "000013",
      "tenant_id": "tenant1",
      "cluster_id": "nam1"
    },
    "received_at" : "2020-02-12T15:15:45.789585559Z"
  }
}
```
:::

::: {.cell .markdown id="Hqm6zJd7Ujg2"}
## Few Possible Vulnerabilities
:::

::: {.cell .markdown id="Jn93RyLROB8B"}
A Brief overview of potential security threats and vulnerabilities in
LoRaWAN, addressing issues such as eavesdropping, device cloning, Denial
of Service (DoS) attacks, and physical attacks, along with their
implications:

1.  **Eavesdropping:** Threat: Unauthorized interception of
    communication between LoRaWAN devices and gateways. Vulnerability:
    Lack of end-to-end encryption for data in transit. Implications:
    Exposure of sensitive information, compromise of data integrity, and
    potential unauthorized access to command and control messages.

------------------------------------------------------------------------

1.  **Device Cloning:** Threat: Replication of device identifiers and
    keys to create unauthorized duplicates of legitimate devices.
    Vulnerability: Weak device authentication and insecure key
    management. Implications: Unauthorized access to the LoRaWAN
    network, potential data manipulation, and compromised trust in the
    device ecosystem.

------------------------------------------------------------------------

1.  **Denial of Service (DoS) Attacks:** Threat: Deliberate actions to
    disrupt the normal functioning of the LoRaWAN network.
    Vulnerability: Lack of robust mechanisms to handle resource
    exhaustion or flooding attacks. Implications: Service disruption,
    unavailability of communication, and potential impact on critical
    IoT applications.

------------------------------------------------------------------------

1.  **Physical Attacks:** Threat: Unauthorized physical access to
    LoRaWAN devices or gateways. Vulnerability: Inadequate physical
    security measures for devices and infrastructure. Implications:
    Tampering with devices, extraction of sensitive information, and
    potential compromise of the entire LoRaWAN network.

------------------------------------------------------------------------

1.  **Impersonation and Spoofing:** Threat: Pretending to be a
    legitimate device or gateway to gain unauthorized access.
    Vulnerability: Weak device authentication and lack of secure session
    establishment.

------------------------------------------------------------------------

**Implications:** Unauthorized data access, injection of false data into
the network, and potential disruption of legitimate communications.
Implications on the Overall System: Data Integrity: Vulnerabilities can
lead to unauthorized access and manipulation of transmitted data,
compromising the integrity of the information exchanged within the
LoRaWAN network.

**Network Reliability:** Security threats, if exploited, can result in
service disruptions, impacting the reliability and availability of the
LoRaWAN network for legitimate users.

**Privacy Concerns:** Eavesdropping and unauthorized access may lead to
privacy breaches, revealing sensitive information about connected
devices and users.

**Trust and Adoption:** Security vulnerabilities can erode trust in the
LoRaWAN ecosystem, potentially hindering the widespread adoption of the
technology.

Addressing these security threats requires the implementation of robust
encryption, secure key management, strong authentication mechanisms, and
ongoing monitoring to detect and respond to potential security
incidents. Regular updates and adherence to best practices are essential
for maintaining a secure and trustworthy LoRaWAN network.
:::

::: {.cell .code id="9aoG3cF-OVl1"}
``` python
```
:::

::: {.cell .markdown id="rU6xfr0Qd2u8"}
## DDoS On LoRaWAN Networks
:::

::: {.cell .markdown id="UaL-h5BUgiaQ"}
### Join accept relay vulnerability
:::

::: {.cell .code id="6IfQtdyUend7"}
``` python
```
:::

::: {.cell .markdown id="AhvA7cKDb5qS"}
## Raspberry Pi code to Generate LoRa Signal
:::

::: {.cell .code id="dQFyXlm_cAOA"}
``` python
!pip install RPi.GPIO
!pip install spidev
!pip install pyLoRa
!pip install pycryptodome
!pip install pycrypto

import numpy as np
import matplotlib.pyplot as plt
from SX127x.LoRa import LoRa2 as LoRa
#from SX127x.board_config import BOARD2 as BOARD

SF = 8  # Spreading Factor
BW = 125  # Bandwidth in kHz
SNR = 10.5  # Signal-to-Noise Ratio in dB
RSSI = -103  # Received Signal Strength Indicator in dBm

# Generate the signal
f_dev = pylora.frequency_deviation(SF, BW)
bitrate = pylora.bitrate(SF, BW)
symbolrate = pylora.symbolrate(SF, BW)
duration = 2  # duration of signal in seconds
data = np.random.randint(0, 2, int(bitrate * duration))
samples = pylora.modulate(data, SF, BW, f_dev, symbolrate)

# Visualize the signal
fig, ax = plt.subplots(figsize=(10, 4))
t = np.arange(0, len(samples)/symbolrate, 1/symbolrate)
ax.plot(t, samples)
ax.set_xlabel('Time (s)')
ax.set_ylabel('Amplitude')
ax.set_title('LoRa Signal with SF={}, BW={}, SNR={} dB, RSSI={} dBm'.format(SF, BW, SNR, RSSI))
plt.show()
```
:::

::: {.cell .markdown id="LV_HnIT4c9Ev"}
## Compare the sent signal and received signal to check the noise and distortion
:::

::: {.cell .code id="DsC1nJmDdPD9"}
``` python
# The code is to generate and check RSSI, SNR and other features of Received Signal

import numpy as np
import matplotlib.pyplot as plt

# Signal parameters
SF = 12
BW = 125e3
fc = 868e6
Rb = BW/(2**(SF))

# Generate signal
SNR = 11.5
signal_length = 1024
signal = np.random.randint(0, 2, signal_length)
signal = 2*signal-1
N = 2**SF
if len(signal) < N:
    signal = np.pad(signal, (0, N-len(signal)), mode='constant')
else:
    signal = signal[:N]

# Generate LoRa chirp
t = np.linspace(0, 1/Rb*N, N)
phi = 2*np.pi*BW/(2**(SF+2))*(t-N/Rb/2)
s_lora = np.real(np.exp(1j*(2*np.pi*fc*t + phi)))
s_lora = s_lora/np.sqrt(np.mean(s_lora**2))

# Add noise to signal
noise_power = np.var(s_lora)/(10**(SNR/10))
noise = np.sqrt(noise_power)*np.random.randn(len(s_lora))
rx_signal = s_lora + noise

# Plot signal
fig, ax = plt.subplots(3, 1, figsize=(12, 8))
ax[0].plot(signal)
ax[0].set_title('Original signal from the Ble Device')

# Plot LoRa chirp
ax[1].plot(s_lora)
ax[1].set_title('Signals after LoRa modulation')

# Plot received signal
ax[2].plot(rx_signal)
ax[2].set_title('Received signal at the Gateway')
plt.tight_layout()
plt.show()
```
:::

::: {.cell .markdown id="JLbFuCrrY-7c"}
## Node red setup for receiving TTN Data
:::

::: {.cell .markdown id="pZLABmVTZPVE"}
**TTN Setup**

Generate a MQTT credentials from the TTN integration section of the TTN
console

![](https://i.ibb.co/1TRgGt7/Screenshot-2024-01-18-171751.png)

**Node-red Setup**

The MQTT credentials copied from the TTN could be easily pasted in a new
MQTT in node.

-   Drag and drop an MQTT-in node from the Node-RED palette onto the
    canvas.
-   Double-click the MQTT-in node to open its configuration dialog.

![](https://i.ibb.co/zhmzxjz/Screenshot-2024-01-18-171414.png)
![](https://i.ibb.co/s9HHQSD/Screenshot-2024-01-18-171440.png)

-   Setup the node-red with the credentials.
:::

::: {.cell .markdown id="q4kDv95ZIBBY"}
## Code to check the user error
:::

::: {.cell .code execution_count="10" colab="{\"base_uri\":\"https://localhost:8080/\"}" id="y1aSGwZkLsNS" outputId="c0468d19-361e-4fa3-eabd-c29df8ab7d7e"}
``` python
import json

def analyze_uplink_message(uplink_message):
    suggestions = []

    # Example: Check RSSI, SNR, and firmware values
    rssi_threshold = -80
    snr_threshold = 5
    threshold_major_version = 2

    rssi = uplink_message['uplink_message']['rx_metadata'][0]['rssi']
    snr = uplink_message['uplink_message']['rx_metadata'][0]['snr']

    if rssi < rssi_threshold:
        suggestions.append("Low RSSI: Device may be too far from the gateway.")
    if snr < snr_threshold:
        suggestions.append("Low SNR: Possible interference or signal quality issues.")

    # Check firmware version
    firmware_version = uplink_message['uplink_message']['version_ids']['hardware_version']
    major_version = int(firmware_version.split('.')[0])

    if major_version < threshold_major_version:
        suggestions.append("Outdated Firmware: Consider updating for security and feature improvements.")

    # Add more checks based on your specific use case

    return suggestions

# Example: Read uplink JSON data from a file
with open('/content/bad-uplink-message.json', 'r') as file:
    uplink_data = json.load(file)

# Example: Analyze the uplink message
suggestions = analyze_uplink_message(uplink_data)

# Example: Display suggestions
if suggestions:
    print("Possible User Errors:")
    for suggestion in suggestions:
        print("- {}".format(suggestion))
else:
    print("No apparent issues detected.")
```

::: {.output .stream .stdout}
    Possible User Errors:
    - Low RSSI: Device may be too far from the gateway.
    - Outdated Firmware: Consider updating for security and feature improvements.
:::
:::
